[toc]



#### 第一章 构建

需求分析和架构时发现的错误最后修复成本不可估量 十到百倍

#### 第二章 隐喻

开发软件比作盖房子 地基很重要

#### 第三章 前期准备

构建活动 项目成本的65% 最糟糕的项目会执行2-3次构建



**软件保质的方法** 

通常会想到测试（项目末期）（不是最有影响的部分）

项目中期——构建实践（本书的重点关注内容）

项目开始——定义问题 需求分析 设计（目的 降低风险）



**开始构建时辨明当前形势如何 如果乌云出现在地平线，退回前期**



如何判断是否已经准备好开始构建工作了

准备不周全的诱因

​	没有前期准备的技能

​	无法抵抗 尽快开始编码

​	管理者忽视构建（答应老板 假装写代码 和老板讲明准备工作的重要 规划项目的微妙 换工作）

​		逻辑 计划 需求

​		规划 建筑蓝图 圣诞树立起来之前你不会去做装饰 在建好的房子下把地板掀开铺一条网线

​				架构师吃掉需求 设计师吃掉架构 程序员消化设计

​		数据 发现错误的时间要尽可能接近引入错误的时间

![image-20220630231142832](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220630231142832.png)



**序列式开发和迭代式开发** 后者常用

问题

**需求**

​	如何判断已经很好的完成了需求分析

​		

​	如何充分利用已有的需求



平均水平的项目 需求会有25%的变化



**构建期间处理需求变更**

​	需求核对表评估

​	

​	确保每一个人都知道需求变更的代价

劝说词 **进度 成本**

​	建立变更控制程序、使用能适应变更的开发方法、放弃项目、注意项目的商业案例



![image-20220701130843204](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220701130843204.png)

![image-20220701130936289](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220701130936289.png)



架构的先决条件

​	架构典型组成部分

​		程序组织 定义程序主要构造块 老生常谈但做不好 低耦合

​		主要的类

​		业务规则

​		用户界面设计

​		资源管理

​		安全性

​		性能

​		可伸缩性 互用性 本地化

​		输入输出

​		错误处理

​			进行纠正还是进行检测?

​			主动还是被动

​		容错性

​		架构的可行性

​		过度工程 健壮性是指系统在检测到错误后继续运行的能力

​						链条的强度=所有薄弱环节的乘积!=最薄弱的一环

​		买还是造的决策 自己定制的组件在哪些方面胜过现成的程序库和组件

​		复用的决策

​		变更策略 保留将来使用的字段、不超过代码生成器的能力范围 表驱动法代替if硬编码

​		架构总体质量 写明排斥可替代方案的根本理由

​								大型系统的本质问题是维持其“概念完整性”

​								架构过程中的变更方式

​								描述主要决策的动机

​								尽可能独立于环境 除非针对特定的机器或语言 

​								明确指出有风险的区域

​								多视角

​								不应包好难理解的地方

![image-20220701135933041](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220701135933041.png)

![image-20220701140152725](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220701140152725.png)

花费在前期准备上的时间长度

​	10-20的工作量 20-30的时间

![image-20220701140512774](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220701140512774.png)

​	构建活动根本目的在于降低风险

​	关注质量

​	理解采用的构建方法

#### 第四章 关键的构建决策

1编程语言 同一个程序员用熟悉语言的高30% 不同程序员熟悉语言高3倍

​				 高级语言比低级语言生产率 可靠性 整洁性 易理解性高5-15倍

 2编程约定 各个部分都能反映架构的内涵

​					统一的规则

​					深入一种语言去编程

3选择主要的构建实现方法

![image-20220709180509297](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220709180509297.png)

![image-20220709180529539](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220709180529539.png)





第二部分 创建高质量的代码



#### 第五章 软件构建中的设计

​	2关键的概念设计

​		软件的首要技术使命：管理复杂度

​		 偶然的难题和本质的难题



理想的设计特征：最小复杂度 易于维护 松散耦合 可扩展性 可重用性 

​	高扇入 大量使用某个给定的类

​	低扇出 少量使用其他的类 不超过7个

​						

设计的层次

第一层 软件系统

第二层 分解为子系统或包

![image-20220710001254605](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220710001254605.png)

​																					  无环图

关于子系统的层次设计 业务规则 用户界面 数据库访问 对系统的依赖性

第三层 分解为类

第四层 分解成子程序

第五层 子程序内部的设计

5.3设计构造块 启发式方法

​	找出现实世界中的对象

​		辨识  对象中的数据data和方法method（何为面向对象

​		确定可以对对象进行的操作

​		确定各个对象能对其他对象进行的操作 包含和继承

​		public private

​		public interface

​	形成一致的抽象

​		好的抽象让你忽略无关的细节

​		“从高层次看待一个对象”

​	封装实现细节

​		“不看对象细节层次”

​	当继承能简化设计时就继承

​		多态

​	**隐藏秘密**

​		隐藏复杂度

​		隐藏变化原

   	 可察觉到性能损耗 

​	信息隐藏的价值

​		修改起来容易4倍

![image-20220711024722794](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220711024722794.png)



​	找出容易改变的区域

​		优秀的设计师都有对变化的预期能力 把不稳定的区域隔离出来

​		措施：

​			找出看起来容易变化的项目

​			把容易变化的项目分离出来

​			把看起来容易变化的项目隔离开来

​				业务规则

​				对硬件的依赖性

​				输入和输出

​				非标准的语言特性

​				困难的设计区域和构造区域

​				状态变量 1用枚举取代布尔 使用访问器子程序取代对状态变量的直接检查（不会让检查语句扩散到程序各处）

​				数据量限制 隐私

​			预料不同程度的变化

​				只有极不可能发生的变化才能导致系统中多于一个类发生明显的变化

​	**保持松散耦合**

​		耦合度表示类与类之间或子程序与子程序之间关系的紧密程度。

​		耦合标准

​			规模 子程序的参数越少越好

​			可见性 通过修改全局数据而使另一模块能够使用该数据 × （第三方）

​						 要通过模块之间的连接关系变得广为人知 应通过参数传递

​			灵活性 指模块间的连接是否容易改动 （实例 让抽象出其他两个地方都适用的格式，修改子程序方法

​			耦合的种类

​				简单数据参数耦合

​				简单对象耦合 模块实例化一个对象

​				对象参数耦合 耦合更紧密

​				语义上的耦合 一个模块不仅使用了另一个模块的语法元素，而且还使用了有关那个模块内部工作细节的语义知识

​				

​	**查阅常用的设计模式**

​				精炼炉众多现成的解决方案

​				适配器 桥接：有几个变化的维度，通过两个类来连接（例子 带颜色的多边形

​							https://www.runoob.com/w3cnote/bridge-pattern2.html

​							 装饰器 外观 工厂方法 观察者 单件 策略 模板方法

​				提供现成的抽象来减少复杂度

​				设计模式通过把常见解决方案的细节予以制度化来减少出错

​				设计模式通过提供多种设计方案而带来启发性的价值

​	**其他的启发式方法**

​		高内聚 构造分层结构：不需要所有时间考虑所有层次 严格描述类契约 分配职责 为测试而设计 避免失误

有意识到选择绑定时间 创建中央控制点 考虑使用蛮力突破 画一个图 保持设计的模块化

​	**设计启发 总结**

![image-20220715191554612](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220715191554612.png)

​	**使用启发式方法的原则**

5.4设计实践

​	分而治之

​	自上而下和自下而上的设计方法

​		自上而下：人的大脑在同一时间只能集中关注一定量的细节 分解

​		自下而上：自上而下过于抽象 合成 难于独立使用——我已经组装完了，为什么盒子里还有零件？

​		自上而下容易上手，但受到底层复杂度的影响， 并不互相排斥 要反复试验

​	建立试验性原型

​	合作设计

​		设计过程中 三个臭皮匠 顶上诸葛亮

​		要做多少设计才够

​			团队经验 系统寿命 可靠度 项目规模 团队大小

​			![image-20220715193535750](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220715193535750.png)

​		最大的设计问题来自我认为很简单的区域

​	**记录你的设计成果**

​		设计文档写入代码里 注释写明关键的设计决策

​		wiki记录讨论决策 总结 

​		适当的细节层创建UML图

5.5对流行的设计方法的评论

​	![image-20220715194920937](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220715194920937.png)



#### 第六章 可以工作的类

6.1类的基础 抽象数据类型ADTs

好处

​	隐藏细节 改动不影响整个程序 让接口提供更多信息 

​	更 容易 提高新能 让程序的正确性显而易见 

![image-20220731193416028](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220731193416028.png)

​	程序更具自我说明性 ？ 无需在程序内到处传递数据 可以想在现实世界中那样操作实体，不用在底层操作



实例 抽象数据类型要尽可能选择最高的抽象层次

​		 把文件这样的常用对象当成ADT

​			操作系统提供了第一层次的抽象以及在该层次上的ADT 高级语言则提供了第二层

![image-20220731195822311](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220731195822311.png)



![image-20220731195922302](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220731195922302.png)

总结 第一层 起好变量名 第二层 隐藏数据类型



在非面向对象环境中ADT处理多份数据实例 未读

6.2良好的类接口 



6.3有关设计和实现的问题

包含

![image-20220803001521831](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803001521831.png)

警惕超过七个数据成员的类

![image-20220803004125045](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803004125045.png)

**这能降低复杂度**

​	确保只继承需要继承的部分

![image-20220803004807897](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803004807897.png)

 如果你想使用一个类的实现而不是接口，那么就应该采用包含方式，而不该用继承

​	把公用的接口数据操作放到继承树中尽可能高的位置

​	只有一个实例的类是值得怀疑的

​	只有一个派生类的基类也值得怀疑 不需要创建并非绝对必要的继承结构

​	

​	**派生后覆盖了某个子程序，但在其中没做任何操作，这种情况也值得怀疑**

​	避免让继承体系过深（限制在2-3层

​	尽量使用多态 避免大量的类型检查

​		多态代替switch shape.Draw()

​	多重继承

​		混合体？

![image-20220803010655370](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803010655370.png)



**成员函数和数据成员**

​	让类中子程序数量尽可能减少

​	禁止隐式产生不需要的函数和运算符

​	减少类所调用的不同子程序的数量

​	对其他类的子程序的间接调用要尽可能少

​	减少类和类间相互合作范围

​		![image-20220803012926486](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803012926486.png)

**构造函数**

​	初始化数据

​	private 构造函数实现单例

**![image-20220803013100716](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803013100716.png)**

​	优先用深拷贝

6.4创建类的原因

​	为抽象对象建模 降低复杂度 隔离复杂度 隐藏实现细节 限制变动的影响范围 隐藏全局数据 让参数传递更顺畅 建立中心控制点 让代码更易于重用 吧相关操作包装到一起 实现某种特定的重构

应避免的类

​	万能类

​	无关紧要的类

​	动词命名的类

6.5 与具体编程语言相关的问题

6.6 超越类：包

![image-20220803170145143](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803170145143.png)

![image-20220803170308472](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803170308472.png)

![image-20220803170330278](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803170330278.png)

![image-20220803170534790](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220803170534790.png)



#### 第七章 高质量的子程序

7.1创建子程序的正当理由

​	降低复杂度 当内部循环或判断条件嵌套层次很深时，意味着需要从子程序中提取新子程序 降低外围复杂度

​	引入中间、易懂的抽象

​	避免代码重复

​	支持子类化 能更容易覆盖

​	隐藏顺序

​	隐藏指针操作

​	提高可移植性

​	**简化复杂的布尔判断**

​		![image-20220804130420617](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220804130420617.png)

​	

​	改善性能

​	确保子程序都很小



**似乎过于简单而没必要写成子程序的操作**

​	可读性高 可扩展性好

7.2在子程序层上设计

​	功能内聚性 顺序内聚性 通信上的内聚性 

​	临时的内聚性

不可取代内聚性：

​	过程上的内聚性（缺乏逻辑的内聚

​		事件处理器

​	巧合的内聚

​	

7.3 好的子程序名字

​	描述所做的事

​	避免模糊的动词 handleOutput-formatAndPrintOutput

​		考虑修改子程序

​	不要仅通过数字来形成不同子程序名字

​	根据需要确定子程序名字长度

​		比变量复杂、所以名字应更长

​	给函数命名时要对返回值有所描述

![image-20220804132922247](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220804132922247.png)

​	给过程起名时使用语气强烈的动词加宾语形式

​	准确使用对仗词

![image-20220804133805631](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220804133805631.png)

​	为常用操作确立命名规则

![image-20220804133905756](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220804133905756.png)

7.4 子程序可以写多长

​	![image-20220804134115539](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220804134115539.png)

![image-20220804134128663](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220804134128663.png)

7.5如何使用子程序参数

​	4成错误 通信时发生

​	按输入-修改-输出的顺序排列参数

​	不要把子程序的参数用作工作变量

​	



？

7.6 使用函数时特别考虑到问题

​	设置返回值

​		检查所有返回路径

​		不要返回指向局部数据的引用或指针

7.7宏子程序和内联子程序

​	宏表达式套括号

​	宏命名

宏子程序使用上的限制

​	万不得已

内联子程序

​	c++ inline 编译时把内联程序转换为内嵌代码避免调用的开销 使代码高效

#### 第八章 防御式编程

8.1保护程序免遭非法输入数据的破坏

​	“垃圾进，什么都不出/出错误提示”

​	检查所有外部来源数据值

​	检查子程序输入参数值

​	决定如何处理错误输入数据

​		迭代设计、编码前先写伪代码、写代码前先写测试用例、低层设计检查等活动有助于防止引入错误。

8.2断言

​	

？

8.3错误处理技术

​	返回中立值

​	换用下一个正确的数据

​	返回与前次相同的数据

​	换用最接近的合法值

​	把警告信息记录到日志文件中

​	返回错误码

​	调用错误处理子程序或对象

​	当错误发生时显示出错信息

​	用最妥当的方式在局部处理错误

​	关闭程序

健壮性与正确性

​	![image-20220815115538291](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220815115538291.png)



8.4异常

![image-20220815121652448](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220815121652448.png)

？

![image-20220815122533691](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220815122533691.png)







8.6辅助调试的代码

不要自动地把产品版的限制强加于开发版之上

尽早引入辅助调试的代码

采用进攻式编程

![image-20220815125527307](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220815125527307.png)

计划一处调试辅助的代码

8.7确定在产品代码中该保留多少防御式代码

![image-20220815125826498](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220815125826498.png)

保留检查重要错误的代码

去掉检查细微错误的代码

去掉可以导致程序硬性崩溃的代码

保留稳妥崩溃的代码

为技术支持人员记录错误信息

确认留在代码中的错误消息是友好的

8.8对防御式编程采取防御的姿态

![image-20220815130104977](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220815130104977.png)

![image-20220815130115826](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220815130115826.png)

![image-20220815130127901](C:\Users\xian\AppData\Roaming\Typora\typora-user-images\image-20220815130127901.png)

#### 第九章 伪代码编程过程

9.1创建类和子程序的步骤概述

